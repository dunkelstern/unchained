# Response Handler

A Response Handler is the workhorse of Unchained. All requests will handled by implementations of this protocol.

## Basic Structure

The minimum part of the `UnchainedResponseHandler` protocol that has to be implemented is the following:

~~~swift
import Unchained
import TwoHundred

public class ExampleResponseHandler: UnchainedResponseHandler {
    public let request: HTTPRequest

    public required init(request: HTTPRequest) {
        self.request = request
    }
}
~~~

This response handler will return HTTP status code 400 (Bad request) for all HTTP verbs as no actual request handling is implemented.

If you want to react to a specific HTTP verb just implement the corresponding function. The function prototype is the same for all HTTP verbs:

- 2 parameters: `parameters: [String]` and `namedParameters: [String:String]`
- Return value `HTTPResponseBase` instance

## CSRF protection

The default request dispatcher requires CSRF tokens for all HTTP verbs except `GET` and `HEAD`. If you want to opt out of this requirement implement the computed attribute `csrfRequired`:

~~~swift
public var csrfRequired: Bool {
    return false
}
~~~

## Overriding the dispatcher

If you want more finegrained control over how your requests are dispatched you may override the default dispatcher implementation:

~~~swift
public func dispatch(parameters: [String], namedParameters: [String:String]) -> HTTPResponseBase
~~~

All requests will be dispatched through this function. The default implementation handles CSRF protection fo you too.

## HTTPRequest

As you will need it all the time, let's discuss the `HTTPRequest` struct:

By default the `HTTPRequest` struct has the following fields:

- `remoteIP`: The remote (client) IP address
- `header`: the HTTP request header
- `data`: the body data
- `middlewareData`: data added by middleware, do not access directly, use the provided extensions the middleware defines.
- `config`: the configuration used

### RequestHeader

The `header` has the following structure:

- `headers`: Array of `(name: String, value: String)` tuples for the HTTP headers. The header names are lowercased.
- `method`: The HTTP method verb used
- `version`: HTTP version used
- `url`: URL that has been called, get parameters are stripped
- `getParameters`: Dictionary with get parameters
- `fragment`: fragment part of the URL (the part after the `#`)
- `cookies`: Array of cookies sent by the client

Additionally you may subscript the `headers` directly with a HTTP header name to fetch the value (like `self.request.header["Content-Type"]`).

## HTTPResponseBase

All HTTP responses that will be delivered inherit from this class. By default it has the following attributes:

- `body`: Array of `SocketData` objects that will be concatenated to form the body data
- `headers`: HTTP headers to send with the response
- `statusCode`: The HTTP status code to send
- `middlewareData`: like in the `HTTPRequest` this is a storage for data generated by middleware, do not access directly.

It also has the function `setCookie` to append a cookie to the response for convenience.

### The `SocketData` enum

The `SocketData` enum has 3 cases with associated values:

- `.StringData(String)`: A simple string to be returned, associated value: `String`
- `.Data([UInt8]`: A byte Array to return, associated value: Array of `UInt8`
- `.File(String)`: A file from disk to stream to the client, associated value: `String` with path to file

You may chain any amount of these in a response body. You may return big files, they are streamed to the client not loaded into RAM.

### Predefined Response Classes

As `HTTPResponseBase` is pretty limited some subclasses are provided for convenience.

#### HTTP response

Just send back a status code and optionally some body data, additional headers and a content type.

Has a simple initializer:

~~~swift
init(_ statusCode: HTTPStatusCode, body: [SocketData]? = nil, headers: [HTTPHeader]? = nil, contentType: String? = nil)
~~~

All parameters except the (unnamed) first parameter `statusCode` are optional.

#### Static file response

Stream out a static file from the configured static file directory.

~~~swift
init(_ path: String, request: HTTPRequest, statusCode: HTTPStatusCode = .Ok, headers: [HTTPHeader]? = nil, contentType: String? = nil)
~~~

The first (unnamed) parameter is a path to a file relative to the static file directory. The response class needs the `request` to fetch the config as it is the only state carrying variable that it has access to. If no `contentType` is supplied the unix `file` tool is employed to determine the mime type.

#### Media file response

Like static file response but with the media file directory as base.

#### Template response

This renders a [Stencil template](https://github.com/kylef/Stencil) with the given context.

~~~swift
init(_ template: String, context: [String:Any], request: HTTPRequest, statusCode: HTTPStatusCode = .Ok, headers: [HTTPHeader]? = nil, contentType: String = "text/html")
~~~

The first (unnamed) parameter is the path to a Stencil template file. `context` is a key/value storage of the context data to render in the template. `request` is the current request object for configuration purposes.

#### JSON response

A JSON response serializes the given `JSONObject` body and sets the correct content type headers.

~~~swift
init(_ statusCode: HTTPStatusCode, body: JSONObject, headers: [HTTPHeader]? = nil, contentType: String = "application/json")
~~~

The first (unnamed) parameter is the HTTP status code to send and the `body` parameter contains a JSON object to serialize. The content type defaults to `application/json`

#### Redirect response

A redirect response sends a HTTP redirect code with a new location. You may choose if the redirect should be permanent (HTTP 301) or temporary (HTTP 303).

~~~swift
init(_ url: String, permanent: Bool = false, headers: [HTTPHeader]? = nil)
~~~

The redirect will be executed by setting a HTTP `Location` header and sending the appropriate status code.

## Predefined Response Handlers

For convenience we have defined some often used response handlers,

### Static file handler

If you want to serve static files or media files directly from Unchained you may use the Static file handler with the correct configuration.

**Example route for `/static` and `/media`:**

~~~swift
Route("^/static/(.*)$", handler: StaticFileHandler.forRoute(self.staticFilesDirectory), name: "static"),
Route("^/media/(.*)$", handler: StaticFileHandler.forRoute(self.mediaFilesDirectory), name: "media")
~~~

To make this work the route initialization in your config has to be `lazy`, else you won't have access to `self`
